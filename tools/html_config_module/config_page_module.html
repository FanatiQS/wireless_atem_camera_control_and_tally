<style>
	/* Do not display page content until device content has been added */
	body {
		display: none;
	}

	/* Animate on background blur when loaded */
	body {
		animation: config-page-blur .8s;
		backdrop-filter: blur(1px);
		-webkit-backdrop-filter: blur(1px);
	}
	@keyframes config-page-blur {
		from {
			backdrop-filter: blur(0);
			-webkit-backdrop-filter: blur(0);
		}
		to {
			backdrop-filter: blur(1px);
			-webkit-backdrop-filter: blur(1px);
		}
	}

	/* Animate form and background blur away when canceled or submitted */
	body {
		transition: -webkit-backdrop-filter 0.8s;
	}
	form {
		transition: transform 0.8s;
	}
	.dying {
		backdrop-filter: blur(0);
		-webkit-backdrop-filter: blur(0);
	}
	.dying form {
		transform: translateY(calc(-100% - 2em));
	}
</style>
<script> // @ts-check
globalThis.promise = new Promise(async (resolve, reject) => {
	// Gets initial state
	const startedWithAddressAttribure = frameElement.hasAttribute("data-addr");
	// @ts-ignore
	let startedHidden = frameElement.hidden;

	try {
		// Ensures host iframe has CSS class that hides iframe before it is activated
		frameElement.classList.add("waccat-config");

		// Delays until host iframe has data-addr attribute set and is not hidden
		if (!startedWithAddressAttribure || startedHidden) {
			await new Promise((resolve) => {
				const mutationObserver = new MutationObserver((mutations) => {
					for (let i = mutations.length - 1; i >= 0; i--) {
						// @ts-ignore
						if (frameElement.hidden) continue;
						if (!frameElement.hasAttribute("data-addr")) {
							startedHidden = false;
							continue;
						}
						resolve();
						mutationObserver.disconnect();
					}
				});
				mutationObserver.observe(frameElement, {
					attributes: true,
					attributeFilter: [ "data-addr", "hidden" ]
				});
			});

			// Restores data-addr and hidden attributes when reloading
			window.onbeforeunload = () => {
				if (startedHidden) {
					// @ts-ignore
					frameElement.hidden = true;
				}
				else if (!startedWithAddressAttribure) {
					frameElement.removeAttribute("data-addr");
				}
			};
		}

		// Gets device address from attribute
		const deviceAddr = `http://${frameElement.getAttribute("data-addr")}`;

		// Gets current nodes in DOM head before overwriting
		const oldHeadNodes = document.head.childNodes;

		// Overwrites DOM with device configuration page HTML
		const deviceConfigPageResponse = await fetch(deviceAddr);
		if (!deviceConfigPageResponse.ok) {
			throw new Error(deviceConfigPageResponse.statusText);
		}
		document.documentElement.innerHTML = await deviceConfigPageResponse.text();
		const form = document.querySelector("form");
		document.body.style.display = "block";

		// Runs supressed script tags that were inserted through innerHTML write
		const oldScriptNode = document.querySelector("script");
		const newScriptNode = document.createElement("script");
		newScriptNode.innerHTML = oldScriptNode.innerHTML;
		oldScriptNode.parentElement.insertBefore(newScriptNode, oldScriptNode);
		oldScriptNode.remove();

		// Inserts extra styles and script back to page after being overwritten
		document.head.append(...oldHeadNodes);

		// Renders host iframe in DOM
		frameElement.classList.add("waccat-config-active");

		// Delays events until after intro animation is finished
		await new Promise((resolve) => document.body.addEventListener("animationend", resolve, { once: true }));

		// Disables host wrapper iframe when animation is done for cancel or submit
		document.body.addEventListener("transitionend", () => {
			if (!document.body.classList.contains("dying")) return;
			frameElement.classList.remove("waccat-config-active");
			if (startedWithAddressAttribure && !startedHidden) return;
			location.reload();
		});

		// Disables overlay form when clicked outside form element
		document.body.onclick = (event) => {
			// Ignores bubbling events
			if (event.target !== document.body) return;

			// Animates page off screen
			document.body.classList.add("dying");

			// Prevent multiple resolves from running active at the same time
			form.onsubmit = null;
			document.body.onclick = null;

			// Resolves promise indicating no configuration was sent
			resolve(false);
		};

		// Prevents submitting form since that updates the content of the page
		(await new Promise((resolve) => form.onsubmit = resolve)).preventDefault();

		// Animates page off screen
		document.body.classList.add("dying");

		// Prevent multiple resolves from running active at the same time
		form.onsubmit = null;
		document.body.onclick = null;

		// Manually submits form
		const postResponse = await fetch(deviceAddr, { method: "POST", body: new FormData(form) });
		if (!postResponse.ok) throw new Error(postResponse.statusText);

		// Resolves promise indicating configuration was successfully sent
		resolve(true);
	}
	catch (err) {
		// Rejects promise with caught error
		reject(err);

		// Opens alert box with error message if attribute is set
		if (frameElement.hasAttribute("data-alert-err")) {
			alert(err.message);
		}

		// Disables wrapper iframe
		if (startedWithAddressAttribure && !startedHidden) return;
		location.reload();
	}
});
</script>
