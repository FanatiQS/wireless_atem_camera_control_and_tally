#include <stdint.h> // uint8_t, uint16_t, UINT8_MAX
#include <assert.h> // assert
#include <stddef.h> // size_t, NULL
#include <stdlib.h> // malloc
#include <string.h> // memcpy
#include <stdio.h> // sprintf, perror
#include <stdlib.h> // abort

#include "../core/atem.h" // ATEM_PACKET_LEN_MAX, ATEM_PACKET_LEN_MAX_SOFT
#include "../core/atem_protocol.h" // ATEM_LEN_HEADER
#include "./atem_session.h" // struct atem_session, atem_session_send
#include "./atem_packet.h" // struct atem_packet, atem_packet_dequeue, atem_packet_enqueue, ATEM_PACKET_FLAG_NONE, ATEM_PACKET_FLAG_RELEASE
#include "./atem_server.h" // atem_server, atem_server_broadcast
#include "./atem_cache.h"



// Camera control data
struct cc_data {
	union {
		struct {
			uint8_t dest;
			uint8_t category;
			uint8_t parameter;
			bool relative;
			uint8_t type;
		};
		uint8_t cc_head[16];
	};
	uint8_t cc_payload[8];
};

// Camera control command data
struct cc_cmd {
	uint8_t cmd_header[ATEM_LEN_CMDHEADER];
	uint8_t cc_head[16];
	uint8_t cc_payload[8];
};

// Input source cache data
struct source_data {
	uint8_t params[44];
	struct cc_cmd focus;
	struct cc_cmd iris;
	struct cc_cmd wb;
	struct cc_cmd shutter;
	struct cc_cmd sharpening;
	struct cc_cmd iso;
	struct cc_cmd iso_old;
	struct cc_cmd nd;
	struct cc_cmd bars;
	struct cc_cmd lift;
	struct cc_cmd gamma;
	struct cc_cmd gain;
	struct cc_cmd offset;
	struct cc_cmd contrast;
	struct cc_cmd luma;
	struct cc_cmd color;
	struct cc_cmd pt;
};

// Hides metadata in ATEM command header padding bytes
struct chunk_data {
	uint16_t padding;
	uint16_t chunk_len;
};

// Cached ATEM server data
static struct {
	void* data;
	struct source_data* source_data;
	uint16_t chunks_count;
} atem_cache_data;



// Gets pointer to camera control parameter in cache
static struct cc_cmd* cc_param_get(uint8_t dest, uint8_t category, uint8_t param) {
	assert(atem_cache_data.data != NULL);
	if (dest == 0) return NULL;

	struct source_data* source_data = &atem_cache_data.source_data[dest - 1];
	switch (category << 8 | param) {
		case 0x0000: return &source_data->focus;
		case 0x0002: return &source_data->iris;
		case 0x0102: return &source_data->wb;
		case 0x0105: return &source_data->shutter;
		case 0x0108: return &source_data->sharpening;
		case 0x010d: return &source_data->iso;
		case 0x0110: return &source_data->nd;
		case 0x0404: return &source_data->bars;
		case 0x0800: return &source_data->lift;
		case 0x0801: return &source_data->gamma;
		case 0x0802: return &source_data->gain;
		case 0x0803: return &source_data->offset;
		case 0x0804: return &source_data->contrast;
		case 0x0805: return &source_data->luma;
		case 0x0806: return &source_data->color;
		case 0x0b00: return &source_data->pt;
		default: return NULL;
	}
}

// Creates ATEM packet buffer from cached data
static uint8_t* atem_cache_buf_create(uint8_t* data, uint16_t remote_id) {
	assert(data != NULL);
	assert(remote_id > 0);

	// Gets packet length
	struct chunk_data* chunk = (void*)data;
	assert(chunk->chunk_len > 0);
	uint16_t packet_len = chunk->chunk_len + ATEM_LEN_HEADER;

	// Allocates buffer for packet
	uint8_t* buf = malloc(packet_len);
	if (buf == NULL) {
		perror("Failed to allocate buffer for cache packet data");
		abort();
	}

	// Sets packet header
	buf[ATEM_INDEX_FLAGS] = ATEM_FLAG_ACKREQ;
	buf[ATEM_INDEX_LEN_HIGH] |= packet_len >> 8;
	buf[ATEM_INDEX_LEN_LOW] = packet_len & 0xff;
	buf[ATEM_INDEX_ACKID_HIGH] = 0x00;
	buf[ATEM_INDEX_ACKID_LOW] = 0x00;
	buf[ATEM_INDEX_LOCALID_HIGH] = 0x00;
	buf[ATEM_INDEX_LOCALID_LOW] = 0x00;
	buf[ATEM_INDEX_UNKNOWNID_HIGH] = 0x00;
	buf[ATEM_INDEX_UNKNOWNID_LOW] = 0x00;
	buf[ATEM_INDEX_REMOTEID_HIGH] = remote_id >> 8;
	buf[ATEM_INDEX_REMOTEID_LOW] = remote_id & 0xff;

	// Copies over data to packet payload
	memcpy(buf + ATEM_LEN_HEADER, data, packet_len - ATEM_LEN_HEADER);

	return buf;
}

// Updates camera control data in cache
static void atem_cache_update_cc(uint8_t* buf_req, uint16_t len) {
	assert(buf_req != NULL);

	// Reads received data as camera control command
	struct cc_data* cc_recv = (struct cc_data*)buf_req;
	if (len != sizeof(*cc_recv)) {
		fprintf(stderr, "Unexpected camera control parameter length: %d\n", len);
		return;
	}

	// Gets pointer to parameter value
	struct cc_cmd* cc_cache = cc_param_get(cc_recv->dest, cc_recv->category, cc_recv->parameter);
	if (cc_cache == NULL) {
		fprintf(stderr, "Invalid parameter: 0x%02x%02x\n", cc_recv->category, cc_recv->parameter);
		return;
	}

	// Updates assignable parameter value in cache for future connecting clients
	if (!cc_recv->relative) {
		assert(sizeof(cc_cache->cc_payload) == sizeof(cc_recv->cc_payload));
		memcpy(cc_cache->cc_payload, cc_recv->cc_payload, sizeof(cc_recv->cc_payload));
	}
	// Updates relative parameter value
	else {
		switch (cc_recv->type) {
			// Updates int8 type
			case 0x01: {
				uint8_t count = cc_recv->cc_head[7];
				int8_t* data_recv = (void*)cc_recv->cc_payload;
				int8_t* data_cache = (void*)cc_cache->cc_payload;
				for (uint8_t i = 0; i < count; i++) {
					int8_t value_cache = data_cache[i];
					int8_t value_recv = data_recv[i];
					data_cache[i] = value_cache + value_recv;
				}
				break;
			}
			// Updates fixed point 5.11 type
			case 0x80:
			// Updates int16 type
			case 0x02: {
				uint8_t count = cc_recv->cc_head[9];
				int16_t* data_recv = (void*)cc_recv->cc_payload;
				int16_t* data_cache = (void*)cc_cache->cc_payload;
				for (uint8_t i = 0; i < count; i++) {
					int16_t value_cache = ntohs(data_cache[i]);
					int16_t value_recv = ntohs(data_recv[i]);
					data_cache[i] = htons(value_cache + value_recv);
				}
				break;
			}
			// Updates int32 type
			case 0x03: {
				uint8_t count = cc_recv->cc_head[11];
				int32_t* data_recv = (void*)cc_recv->cc_payload;
				int32_t* data_cache = (void*)cc_cache->cc_payload;
				for (uint8_t i = 0; i < count; i++) {
					int32_t value_cache = ntohl(data_cache[i]);
					int32_t value_recv = ntohl(data_recv[i]);
					data_cache[i] = htonl(value_cache + value_recv);
				}
				break;
			}
			// Rejects relative update with unknown data type
			default: {
				fprintf(stderr, "Unsupported data type: %x\n", cc_recv->type);
				return;
			}
		}
	}

	// Broadcasts parameter update to all connected clients
	uint8_t res_len = sizeof(*cc_cache) + ATEM_LEN_HEADER;
	uint8_t* res_buf = malloc(res_len);
	res_buf[0] = ATEM_FLAG_ACKREQ;
	res_buf[1] = res_len;
	memset(res_buf + 4, 0, 6);
	memcpy(res_buf + ATEM_LEN_HEADER, cc_cache, sizeof(*cc_cache));
	atem_server_broadcast(res_buf, ATEM_PACKET_FLAG_RELEASE);
}

// Initializes ATEM cache data based on input source count
void atem_cache_init(uint8_t source_count) {
	assert(source_count <= (UINT8_MAX - 1));
	assert(source_count > 0);

	// Required non-modifiable ATEM commands
	const uint8_t fixed_head[] = {
		0x00, 0x0c, 0x00, 0x00, 0x5f, 0x76, 0x65, 0x72, 0x00, 0x02, 0x00, 0x1e, 0x00, 0x34, 0x00, 0x00,
		0x5f, 0x70, 0x69, 0x6e, 0x41, 0x54, 0x45, 0x4d, 0x20, 0x45, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x6f,
		0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x00, 0x0c, 0x00, 0x00, 0x5f, 0x56, 0x4d, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00,
		0x50, 0x6f, 0x77, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x56, 0x69, 0x64, 0x4d,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x4c, 0x4b, 0x53, 0x54, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x0c, 0x00, 0x00, 0x5f, 0x4d, 0x41, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00,
		0x4d, 0x52, 0x50, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x4d, 0x52, 0x63, 0x53,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x5f, 0x6d, 0x70, 0x6c, 0x01, 0x00, 0x00, 0x00,
		0x00, 0x20, 0x00, 0x00, 0x4d, 0x50, 0x66, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x2c, 0x00, 0x00, 0x49, 0x6e, 0x50, 0x72, 0x07, 0xd1, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x20,
		0x31, 0x00, 0x00, 0x00, 0x50, 0xbc, 0x4e, 0x90, 0x50, 0xbc, 0x4e, 0x90, 0x50, 0x4f, 0x43, 0x4f,
		0x4c, 0x31, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x03, 0x16, 0x02, 0x01, 0x00, 0x10, 0x00, 0x00,
		0x43, 0x6f, 0x6c, 0x56, 0x00, 0x21, 0x01, 0xf4, 0x03, 0xe8, 0x01, 0xf4,

		0x00, 0x24, 0x00, 0x00, 0x5f, 0x74, 0x6f, 0x70, 0x01, source_count + 1, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00
	};
	const uint8_t fixed_tail[] = {
        0x00, 0x1c, 0x00, 0x00, 0x52, 0x58, 0x4d, 0x53, 0x00, 0x00, 0x0b, 0xc2, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xa2, 0x00, 0x00, 0x00, 0x6e, 0x00, 0x02, 0x00, 0x04, 0x00, 0x1c, 0x00, 0x00,
		0x52, 0x58, 0x43, 0x50, 0x00, 0x00, 0x01, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x6e, 0x00, 0x28, 0x00, 0x00, 0x52, 0x58, 0x53, 0x53,
		0x00, 0x00, 0x55, 0x53, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x64,
		0x00, 0x0c, 0x00, 0x00, 0x52, 0x58, 0x43, 0x43, 0x00, 0x00, 0x00, 0x64, 0x00, 0x0c, 0x00, 0x00,
		0x43, 0x43, 0x73, 0x74, 0x00, 0x00, 0x13, 0x88, 0x00, 0x0c, 0x00, 0x00, 0x50, 0x72, 0x67, 0x49,
		0x00, 0x00, 0x00, 0x01, 0x00, 0x10, 0x00, 0x00, 0x50, 0x72, 0x76, 0x49, 0x00, 0x24, 0x00, 0x01,
		0x00, 0x2e, 0xc0, 0x64, 0x00, 0x0c, 0x00, 0x00, 0x46, 0x74, 0x62, 0x53, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x0c, 0x00, 0x00, 0x4d, 0x50, 0x43, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x00, 0x00,
		0x52, 0x58, 0x48, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x49, 0x6e, 0x43, 0x6d,
		0x01, 0x01, 0x08, 0x01
	};

	// Allocates commands memory based on commands memory requirements
	const size_t cc_len = sizeof(*atem_cache_data.source_data) * source_count;
	const size_t data_len = sizeof(fixed_head) + sizeof(fixed_tail) + cc_len;
	uint8_t* cmd_buf = malloc(data_len);
	atem_cache_data.data = cmd_buf;
	if (cmd_buf == NULL) {
		perror("Failed to allocate cache data");
		abort();
	}

	// Copies over commands required before input sources data
	memcpy(cmd_buf, fixed_head, sizeof(fixed_head));
	cmd_buf += sizeof(fixed_head);

	// Initializes data connected to specific input source
	atem_cache_data.source_data = (void*)cmd_buf;
	for (uint8_t i = 0; i < source_count; i++) {
		const uint8_t dest = i + 1;
		atem_cache_data.source_data[i] = (const struct source_data){
			// Input source configuration command
			.params = {
				0x00, 0x2c, 0x00, 0x00, 0x49, 0x6e, 0x50, 0x72,
				0x00, dest,
				0x43, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x20, 0x31, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x43, 0x41, 0x4d, 0x31,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01
			},

			// Camera control command headers
			.focus.cmd_header =      { 0x00, 0x20, 0x00, 0x00, 0x43, 0x43, 0x64, 0x50 },
			.iris.cmd_header =       { 0x00, 0x20, 0x00, 0x00, 0x43, 0x43, 0x64, 0x50 },
			.wb.cmd_header =         { 0x00, 0x20, 0x00, 0x00, 0x43, 0x43, 0x64, 0x50 },
			.shutter.cmd_header =    { 0x00, 0x20, 0x00, 0x00, 0x43, 0x43, 0x64, 0x50 },
			.sharpening.cmd_header = { 0x00, 0x20, 0x00, 0x00, 0x43, 0x43, 0x64, 0x50 },
			.iso.cmd_header =        { 0x00, 0x20, 0x00, 0x00, 0x43, 0x43, 0x64, 0x50 },
			.iso_old.cmd_header =    { 0x00, 0x20, 0x00, 0x00, 0x43, 0x43, 0x64, 0x50 },
			.nd.cmd_header =         { 0x00, 0x20, 0x00, 0x00, 0x43, 0x43, 0x64, 0x50 },
			.bars.cmd_header =       { 0x00, 0x20, 0x00, 0x00, 0x43, 0x43, 0x64, 0x50 },
			.lift.cmd_header =       { 0x00, 0x20, 0x00, 0x00, 0x43, 0x43, 0x64, 0x50 },
			.gamma.cmd_header =      { 0x00, 0x20, 0x00, 0x00, 0x43, 0x43, 0x64, 0x50 },
			.gain.cmd_header =       { 0x00, 0x20, 0x00, 0x00, 0x43, 0x43, 0x64, 0x50 },
			.offset.cmd_header =     { 0x00, 0x20, 0x00, 0x00, 0x43, 0x43, 0x64, 0x50 },
			.contrast.cmd_header =   { 0x00, 0x20, 0x00, 0x00, 0x43, 0x43, 0x64, 0x50 },
			.luma.cmd_header =       { 0x00, 0x20, 0x00, 0x00, 0x43, 0x43, 0x64, 0x50 },
			.color.cmd_header =      { 0x00, 0x20, 0x00, 0x00, 0x43, 0x43, 0x64, 0x50 },
			.pt.cmd_header =         { 0x00, 0x20, 0x00, 0x00, 0x43, 0x43, 0x64, 0x50 },

			// Camera control fixed parameter info
			.focus.cc_head =      { dest, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 },
			.iris.cc_head =       { dest, 0x00, 0x02, 0x80, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 },
			.wb.cc_head =         { dest, 0x01, 0x02, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00 },
			.shutter.cc_head =    { dest, 0x01, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
			.sharpening.cc_head = { dest, 0x01, 0x08, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 },
			.iso.cc_head =        { dest, 0x01, 0x0d, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 },
			.iso_old.cc_head =    { dest, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 },
			.nd.cc_head =         { dest, 0x01, 0x10, 0x80, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 },
			.bars.cc_head =       { dest, 0x04, 0x04, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 },
			.lift.cc_head =       { dest, 0x08, 0x00, 0x80, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00 },
			.gamma.cc_head =      { dest, 0x08, 0x01, 0x80, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00 },
			.gain.cc_head =       { dest, 0x08, 0x02, 0x80, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00 },
			.offset.cc_head =     { dest, 0x08, 0x03, 0x80, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00 },
			.contrast.cc_head =   { dest, 0x08, 0x04, 0x80, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00 },
			.luma.cc_head =       { dest, 0x08, 0x05, 0x80, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 },
			.color.cc_head =      { dest, 0x08, 0x06, 0x80, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00 },
			.pt.cc_head =         { dest, 0x0b, 0x00, 0x80, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00 },

			// Camera control modifiable parameter data
			.focus.cc_payload =      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
			.iris.cc_payload =       { 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
			.wb.cc_payload =         { 0x15, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
			.shutter.cc_payload =    { 0x00, 0x00, 0x4e, 0x20, 0x00, 0x00, 0x00, 0x00 },
			.sharpening.cc_payload = { 0x01, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
			.iso.cc_payload =        { 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
			.iso_old.cc_payload =    { 0x02, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
			.nd.cc_payload =         { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
			.bars.cc_payload =       { 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
			.lift.cc_payload =       { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
			.gamma.cc_payload =      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
			.gain.cc_payload =       { 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00 },
			.offset.cc_payload =     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
			.contrast.cc_payload =   { 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00 },
			.luma.cc_payload =       { 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
			.color.cc_payload =      { 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00 },
			.pt.cc_payload =         { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
		};

		// Sets long input source name
		sprintf((char*)&atem_cache_data.source_data[i].params[10], "Camera %d", dest);

		// Sets short input source name
		uint8_t* name_short = &atem_cache_data.source_data[i].params[30];
		if (dest < 10) {
			name_short[3] = dest + '0';
		}
		else if (dest < 100) {
			name_short[3] = (dest % 10) + '0';
			name_short[2] = (dest / 10) + '0';
			name_short[1] = 'M';
		}
		else {
			uint8_t value = dest;
			name_short[3] = (value % 10) + '0';
			value /= 10;
			name_short[2] = (value % 10) + '0';
			name_short[1] = (value / 10) + '0';
		}
	}
	cmd_buf += sizeof(*atem_cache_data.source_data) * source_count;

	// Copies over commands required after input sources data
	memcpy(cmd_buf, fixed_tail, sizeof(fixed_tail));

	// Marks chunk lengths within padding bytes in command headers
	size_t data_remaining = data_len;
	uint8_t* cmd_ptr = atem_cache_data.data;
	struct chunk_data* chunk = (void*)cmd_ptr;
	chunk->chunk_len = 0;
	atem_cache_data.chunks_count = 1;
	while (chunk->chunk_len < data_remaining) {
		// Gets current commands length
		uint16_t cmd_len = (cmd_ptr[0] << 8 | cmd_ptr[1]) & ATEM_PACKET_LEN_MAX;

		// Moves to next chunk if no more data can fit
		if ((chunk->chunk_len + cmd_len) > (ATEM_PACKET_LEN_MAX_SOFT - ATEM_LEN_HEADER)) {
			data_remaining -= chunk->chunk_len;
			chunk = (void*)cmd_ptr;
			chunk->chunk_len = 0;
			atem_cache_data.chunks_count++;
		}

		// Adds command length and moves to next command
		chunk->chunk_len += cmd_len;
		cmd_ptr += cmd_len;
	}
	assert(data_remaining == chunk->chunk_len);
}

// Releases cache memory
void atem_cache_release(void) {
	free(atem_cache_data.data);
}

// Dumps entire server state on newly connected session
void atem_cache_dump(struct atem_session* session, struct atem_packet* packet) {
	assert(session != NULL);
	assert(atem_session_lookup_get(session->session_id) < atem_server.sessions_connected);
	assert(packet != NULL);
	assert(packet->sessions_remaining == 1);

	// Gets cache data array
	uint8_t* data = atem_cache_data.data;
	assert(data != NULL);

	// Dumps first cache data buffer using existing packet
	packet->buf = atem_cache_buf_create(data, 1);
	atem_session_send(session, packet->buf);
	atem_packet_dequeue(packet);
	atem_packet_enqueue(packet, ATEM_PACKET_FLAG_NONE);
	packet->sessions[0].remote_id_low = 1;

	// Dumps remaining cache data buffers
	for (uint16_t i = 1; i < atem_cache_data.chunks_count; i++) {
		// Move to the next chunk
		struct chunk_data* chunk = (void*)data;
		data += chunk->chunk_len;

		// Sends packet and enqueues on global queue
		uint8_t* buf = atem_cache_buf_create(data, i + 1);
		struct atem_packet* packet_next = atem_packet_create(buf, 1);
		atem_session_send(session, packet_next->buf);
		atem_packet_enqueue(packet_next, ATEM_PACKET_FLAG_RELEASE);

		// Sets up packet info
		packet_next->sessions[0].session_id = session->session_id;
		packet_next->sessions[0].packet_session_index = packet->sessions[0].packet_session_index;
		packet_next->sessions[0].remote_id_high = 0;
		packet_next->sessions[0].remote_id_low = i + 1;

		// Places packet onto the local session packet queue
		packet->sessions[0].packet_next = packet_next;
		packet->sessions[0].packet_session_index_next = 0;
		packet = packet_next;
	}

	// Ends local packet queue correctly
	packet->sessions[0].packet_next = NULL;
	session->packet_tail = packet;
	session->packet_session_index_tail = 0;
	session->remote_id = atem_cache_data.chunks_count;
}

// Updates ATEM cache data from ATEM command
void atem_cache_update(uint8_t* buf, uint16_t len) {
	assert(buf != NULL);

	uint16_t offset = ATEM_LEN_HEADER;
	while (offset < len) {
		// Parses command header
		uint8_t* cmd_buf = &buf[offset];
		uint16_t cmd_len = cmd_buf[0] << 8 | cmd_buf[1];
		uint32_t cmd_name = (cmd_buf[4] << 24) | (cmd_buf[5] << 16) | (cmd_buf[6] << 8) | (cmd_buf[7]);
		offset += cmd_len;

		// Processes command
		switch (cmd_name) {
			// Updates ATEM camera control data
			case ATEM_CMDNAME('C', 'C', 'm', 'd'): {
				atem_cache_update_cc(cmd_buf + ATEM_LEN_CMDHEADER, cmd_len - ATEM_LEN_CMDHEADER);
				break;
			}
		}
	}
}
